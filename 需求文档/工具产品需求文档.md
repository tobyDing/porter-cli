porter-ci 工具产品需求文档

## 功能描述

- porter-ci 是一个基于 git 实现跨项目代码功能同步的 ci 工具。
- porter-ci 可以实现跨项目的代码功能同步，例如：当一个项目的代码发生改变时， porter-ci 可以自动将该项目的代码同步到其他目标项目中。
- 实现同步的原理是依赖 git cherry-pick 命令，将一个项目的代码变更应用到其他项目中。遇到冲突，需要用户手动解决冲突

## 使用流程

- 用户在任意目录下执行 `porter-ci` 命令，porter-ci 会自动读取项目的配置文件 `porter-ci.config.json`。
- porter-ci 会根据配置文件中的 projectPath 字段指定的项目为源项目，以该项目的分支的代码变更为基准，将变更应用到其他项目中。
- 同步完成后， porter-ci 会提示用户同步成功。

## 实现流程

实现流程分为以下几个步骤：启动工具、读取并检查信息、同步代码

### 功能设计实现原则

- **约定优于配置**
  - 配置文件`porter-ci.config.json`
    - 配置文件为 porter-ci.config.json，可以放在任意目录下。详细定义参考 [示例配置文件]
    - 配置文件定义了同步的源项目和目标项目的配置信息。
    - 配置信息重点字段描述，如下：
      - `projectName`：源项目的名称，用于在同步时提示用户。必填项，不填报错。
      - `projectPath`：源项目的目录路径，指向同步的源项目。必填项，不填报错。
      - `branch`：源项目的分支，必须指定。必填项，不填报错。分支名称，无特殊要求
      - `commit-id`：指定同步的 commit 范围或自定义提交列表。选填项，如果不指定，默认从源项目指定分支的创建开始新增的第一个 commit 开始同步。
        - 字符串格式：指定从该 commit 开始同步（包括该 commit）
          - 支持完整的 commit-id（如 e3c71183b6b2c1c1d2e3f4a5b6c7d8e9f0a1b2c3）
          - 支持短 commit-id（如 e3c7118），工具会自动识别并扩展为完整的 commit-id
        - 数组格式：指定要同步的具体 commit-id 列表
          - 每个元素可以是完整或短的 commit-id
          - 工具将按照数组中的顺序同步这些提交
          - 示例：`["e3c7118", "a1b2c3d", "4567890"]`
      - `targetProjects`：要同步的目标项目列表，每个项目包含以下字段：
        - `projectName`：项目的名称，用于在同步时提示用户。必填项，不填报错。
        - `projectPath`：项目的路径，用于指定要同步的项目路径。必填项，不填报错。
        - `branch`：要同步的目标分支。必填项，不填报错。
          - 分支名称不应包含`master`、`test`等关键字，否则会抛错提示用户分支名称不对。
- **少即是多**
  - 能在`读取并检查信息`这一步提前发现问题，就在这一步拦截提示，省去同步时复杂的处理流程，减少不可控因素。

### 启动工具

- `porter-ci`启动时，进行必要的提示
  - 询问用户是否填写 porter-ci 配置文件
    - 如果用户没有填写 porter-ci 配置文件，进行如下操作：
      - 询问用户是否要创建一个 porter-ci 配置文件。
        - 如果用户选择创建，按照[示例配置文件]在当前目录创建一个 porter-ci.config.json 文件。
          - 执行复制文件操作。
        - 如果用户选择不创建，提示用户稍后手动创建配置文件，ci 工具退出并停止运行。
  - 读取配置文件中 源项目的名称、分支名称。提示用户源项目的名称、分支名称。
  - 用户确认无误后，询问是否启动同步

### 读取并检查信息

- 读取项目的配置文件信息。
- 检查项目的配置文件信息。
  - 检查配置文件格式是否正确、必要字段是否存在，检查不对，抛错提示用户，退出运行。
- 检查源项目
  - 检查源项目是否存在。不存在，抛错提示用户，退出运行。
  - 检查源项目的分支是否存在。不存在，抛错提示用户，退出运行。
  - 检查源项目的分支自创建以来，是否有新增的提交。必须有新增的提交，否则，抛错提示用户，退出运行。
  - 检查源项目 `commit-id` 是否存在。
    - 如果指定了 commit-id，检查该 commit-id 是否仓库存在。不存在，抛错提示用户，退出运行。
- 检查目标项目
  - 检查目标项目是否存在。不存在，抛错提示用户，退出运行。
  - 检查目标项目的分支是否存在。不存在，抛错提示用户，退出运行。
  - 检查目标项目的分支名称是否符合规范，是否包含`master`、`test`等关键字。如果包含，抛错提示用户，退出运行。
  - 检查目标项目的分支是否有没有`git add`的变更。如果有，抛错提示用户，退出运行。
  - 目标项目可能存在多个，每个项目都要依次执行上述`检查目标项目`流程。
    - 如果有项目检查失败，抛错提示用户，退出运行。
    - 全部检查成功，继续下一步。
- 以上任意检查一旦不通过，抛错提示用户做出相应修改
  - 检查阶段抛错后，ci 工具退出并停止运行，不继续执行同步代码。
  - 用户需要重新执行 porter-ci 命令。
  - 以上`启动工具-读取并检查信息`过程，用户重复执行，直至用户信息全部校验通过，再进行下一步
- 检查通过后，提示用户检查通过，进行同步流程。

### 同步代码

- 根据配置文件中的配置信息，将所有的提交 commit 遴选到目标项目的指定分支中。
- 利用`git cherry-pick`命令，将源项目的提交应用到目标项目中。
- 源项目的指定提交获取逻辑，描述如下：
  - 如果指定了 commit-id，从指定的 commit-id 开始同步。
  - 如果没有指定 commit-id，从源项目指定分支的创建开始新增的第一个 commit 开始同步。
- 如果配置文件配置的目标项目存在多个，也需要依次一个个项目、一个个提交进行同步，串行，非并行。
- 同步代码逻辑，做如下约定：
  - 不是一次性的提交，而是每次提交一个 commit。
  - 如果是跨项目同步代码，采用添加临时远程仓库方案，具体示例参考[跨项目遴选代码示例](./跨项目遴选代码示例.md)，而不是直接从项目的分支上 cherry-pick。
  - 跨项目同步时生成的临时远程仓库管理：
    - 无论同步过程是否成功、是否中途失败退出，都必须确保临时远程仓库被正确清理
    - 程序正常完成同步后，必须清理临时远程仓库
    - 程序因任何错误（如代码冲突、用户中断、系统错误等）退出前，必须清理临时远程仓库
  - 如果同步失败，提示用户手动解决，等待用户手动解决问题后，再继续提交下一个 commit。
    - 等待用户手动解决的时候，工具程序不应该退出，需要利用`inquirer.prompt`等工具让用户对解决的结果做选择，提供操作选项，如下：
      - 继续同步: 继续同步下一个提交。
      - 取消当前同步: 取消当前同步操作，进行下一个提交同步。类似于跳过功能。
      - 退出程序: 直接退出程序。
      - 重新再试: 先取消当前的 cherry-pick 操作，再重新执行当前提交。
    - 用户手动解决问题后，选择继续同步，默认当前提交处理成功，工具程序应该继续执行下一个提交。
    - 关于失败的处理，这里有个特殊的情况，就是 执行`git cherry-pick`，遇到冲突，就会抛错，但是明明是代码冲突导致的报错，抛的错误却没有明确报代码冲突，也不会自动打印清晰的“CONFLICT”提示，这里提供一个修正方案：
      - 捕获 `git cherry-pick` 失败报错
      - 如果明确是代码冲突导致的报错，要明确提示出来是代码冲突导致的失败，提示用户手动解决代码冲突。
      - 否则，主动检测冲突标记，检测是否差异文件包含冲突标记
      - 如果检测到冲突标记，就是认为是合并冲突导致的报错，提示用户手动解决合并冲突。
  - 如果成功，使用 `git add .` 将代码暂存，然后再执行下一次提交。
  - 如此往复，直到全部提交完成。
- porter-ci 只负责代码的同步，不负责代码的`git commit`和推送远程分支。
- 同步完成后，提示用户同步完成，提示用户需人工确认代码并提交代码。
- 最后退出程序。

## 版本发布

### 发布流程

- 版本发布遵循 semver 规范。
- 借助**release-it**实现本地版本自动化处理
  - 先本地开发验证最终打 tags,再推送 tags
  - `release-it` 的使用
    - 添加 npm script 到 package.json 中，如下：
      ```json
      {
        "scripts": {
          "release": "release-it"
        }
      }
      ```
    - conventional-changelog（通过插件集成）
      - 基于 commit 规范自动生成 CHANGELOG
- 借助 GitHub Actions 基于 tag 触发发布 → 解耦开发与发布。
- 开发 → 提 PR → 合并到 main（不发布）
- 准备发布时，本地运行 `pnpm run release`
  - 分析 commit 决定版本号（patch/minor/major）
  - bump version
  - 自动生成 changelog
  - 打本地 tag(如 v1.2.3)
  - **不会**自动推送到远程,手动推送（确认无误后）
  - **注意**此过程借助**release-it**实现
    - 在 release-it 配置中显式禁用自动 push
      - 示例配置文件内容如下：
        ```json
        {
          "git": {
            "push": false,
            "commitMessage": "chore(release): v${version}"
          },
          "npm": {
            "publish": false
          }
        }
        ```
      - 在 CI 中校验 tag 是否由 release-it 生成
        - 可通过正则检查 tag 是否匹配 v\d+\.\d+\.\d+，避免误触发。
- 运行 `git push --follow-tags origin main`
- GitHub Actions 检测到 tag → 自动：
  - 触发 GitHub Actions 工作流程
  - 工作流程中包含以下步骤：
    - 检查 tag 是否符合 semver 规范
    - 安装项目依赖
    - 构建项目 `pnpm run build`
    - 发布项目到 npm registry
      - 注意用**npm 而不是 pnpm**`npm publish --access public`
    - 创建 GitHub Release 页面（含 changelog）
  - 注意 ci 工具的 node 版本应该和项目的 node 版本保持一致。

### 发布注意事项

- 发布前，确保项目的代码已经提交到远程仓库，并且所有的变更都已经合并到 main 分支。
- 发布前，确保项目的依赖已经安装完成，并且项目的代码可以正常构建。
- 本地充分测试后再打 tag
  - 确保 `npm pack` 能生成正确的 tarball
    - 相当于预构建，看看是否能打包出别人可以安装使用的 tar 文件
  - 本地运行 `npm publish --dry-run`（模拟发布）
  - 确认 CHANGELOG.md 和版本号正确
- 考虑“两阶段发布”
  - 第一阶段：推一个 预发布 tag（如 v1.2.0-beta.1）
    - 验证 CI 全流程成功
  - 第二阶段：打正式 tag v1.2.0
- 关键原则：
  - Tag 即承诺
    - **不要删除远程 tag**（破坏历史，对协作者不友好）
    - 一旦推送 tag，就应视为“准备发布”，需确保流程高可靠
  - 版本号不可重用
    - 不能使用已发布的版本号，避免版本号冲突。
    - 累增即可，如 v1.2.0 发布失败，解决完问题，就再下一个版本号为 v1.2.1，依此类推。不要重复使用 v1.2.0 这个版本号。
  - 本地验证优先
    - 确保在发布前，本地已经测试通过，没有问题。
  - ci 配置要健壮
    - 确保 ci 配置文件中包含必要的步骤，例如：安装依赖、构建项目、发布项目等。
    - 确保 ci 配置文件中没有错误，例如：语法错误、配置错误等。

## 技术栈

- 使用 node.js 实现工具的功能。node 版本需要 22 版本以上，建议使用 22.18.0 版本。
- 使用 nvm 工具管理 node 版本需要项目显式指定 node 版本，例如：在项目根目录下创建 .nvmrc 文件，文件内容为 22.18.0。
- 使用 pnpm 工具管理项目依赖
- 使用当前构建 cli 包流行的构建技术，打包构建代码。如 vite 等。
- 使用 typescript 实现代码的类型检查。
- 使用 eslint 工具检查代码质量。
- 使用 prettier 工具格式化代码。
- 使用 git 命令行工具实现代码的同步。
- 在项目中集成 husky+lint-staged+prettier+eslint+commitlint 的工具，用于提高代码质量，规范提交信息。参考版本，如下：
  - husky 使用 ^7.0.0 版本
  - lint-staged 使用 ^9.0.0 版本
  - prettier 使用 ^2.5.0 版本
  - 要求没有兼容问题

## 项目规范

- package.json 中必须包含 `bin` 字段，指定 cli 命令的名称为 `porter-ci`。
- package.json 文件需要包含项目必要的信息
  - 例如：项目名称、项目描述、项目版本、项目依赖、启动调试打包等脚本命令。
  - 保证开发者可以方便地开发、调试 cli 工具。
- 代码需要包含必要的注释、说明文档。方便开发者理解。
  - 注释需要包含必要的信息，例如：函数的参数、返回值、异常等。
  - 说明文档需要包含必要的信息，例如：使用流程、实现流程等。

<!-- 参考链接 -->

[示例配置文件]: /src/template/porter-ci.config.json
